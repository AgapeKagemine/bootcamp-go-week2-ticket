// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package gotik

import (
	"context"
	"database/sql"
)

const create = `-- name: Create :one
INSERT INTO
    users (username, phone, email, balance)
VALUES
    ($1, $2, $3, $4)
RETURNING
    id, username, phone, email, balance
`

type CreateParams struct {
	Username sql.NullString `json:"username"`
	Phone    sql.NullString `json:"phone"`
	Email    sql.NullString `json:"email"`
	Balance  sql.NullString `json:"balance"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (User, error) {
	row := q.queryRow(ctx, q.createStmt, create,
		arg.Username,
		arg.Phone,
		arg.Email,
		arg.Balance,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Phone,
		&i.Email,
		&i.Balance,
	)
	return i, err
}

const deleteById = `-- name: DeleteById :exec
DELETE FROM 
    users
WHERE
    id = $1
`

func (q *Queries) DeleteById(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteByIdStmt, deleteById, id)
	return err
}

const findAll = `-- name: FindAll :many
SELECT
    id, username, phone, email, balance
FROM
    users
`

func (q *Queries) FindAll(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.findAllStmt, findAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Phone,
			&i.Email,
			&i.Balance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findById = `-- name: FindById :one
SELECT 
    id, username, phone, email, balance
FROM
    users
WHERE 
    id = $1
`

func (q *Queries) FindById(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.findByIdStmt, findById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Phone,
		&i.Email,
		&i.Balance,
	)
	return i, err
}

const update = `-- name: Update :exec
UPDATE
    users
SET
    username = $2,
    phone = $3,
    email = $4,
    balance = $5
WHERE 
    id = $1
RETURNING
    id, username, phone, email, balance
`

type UpdateParams struct {
	ID       int64          `json:"id"`
	Username sql.NullString `json:"username"`
	Phone    sql.NullString `json:"phone"`
	Email    sql.NullString `json:"email"`
	Balance  sql.NullString `json:"balance"`
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) error {
	_, err := q.exec(ctx, q.updateStmt, update,
		arg.ID,
		arg.Username,
		arg.Phone,
		arg.Email,
		arg.Balance,
	)
	return err
}
